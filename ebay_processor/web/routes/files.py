# ebay_processor/web/routes/files.py
"""
File Management Routes.

This module handles all user interactions with generated files:
- Download of individual files.
- Download of consolidated ZIP archive.
- Viewing and deletion of files on the server.
"""

import logging
import os
import glob
from datetime import datetime

from flask import (
    Blueprint,
    redirect,
    url_for,
    flash,
    session,
    send_file,
    current_app,
    render_template,
    request,
)
from werkzeug.utils import secure_filename

from ..decorators import login_required

logger = logging.getLogger(__name__)

# Create the Blueprint for file routes.
files_bp = Blueprint(
    'files',
    __name__,
    template_folder='../../templates',
    static_folder='../../static'
)


@files_bp.route('/download/file/<path:filename>')
@login_required
def download_single_file(filename: str):
    """
    Downloads a specific file generated by a process.
    The filename is obtained from the session for security.
    """
    # Use werkzeug.utils.secure_filename to sanitize the filename.
    safe_filename = secure_filename(filename)

    # Get the full file path from the information saved in the session.
    file_paths = session.get('generated_files', {})
    file_path = file_paths.get(safe_filename)

    if not file_path:
        logger.error(f"File not found in session: '{safe_filename}' by user '{session.get('user_id')}'.")
        flash(f'The file "{safe_filename}" is not available for download. The session may have expired.', 'warning')
        return redirect(url_for('processing.index'))
    
    if not os.path.isfile(file_path):
        logger.error(f"Physical file not found: '{file_path}' for user '{session.get('user_id')}'.")
        flash(f'The file "{safe_filename}" does not exist on the server. It may have been deleted.', 'danger')
        return redirect(url_for('processing.index'))

    logger.info(f"User '{session.get('user_id')}' downloading file: {file_path}")
    
    # send_file handles sending the file to the browser as an attachment.
    return send_file(file_path, as_attachment=True)


@files_bp.route('/download/zip')
@login_required
def download_zip_archive():
    """Downloads the ZIP file containing all files from a process."""
    zip_path = session.get('zip_file_path')

    if not zip_path or not os.path.isfile(zip_path):
        logger.error(f"ZIP file download attempt not found by user '{session.get('user_id')}'. Expected path: {zip_path}")
        flash('The ZIP file for this process was not found or the session has expired.', 'danger')
        return redirect(request.referrer or url_for('processing.index'))

    logger.info(f"User '{session.get('user_id')}' downloading ZIP file: {zip_path}")
    
    return send_file(zip_path, as_attachment=True)


@files_bp.route('/manage-files', methods=['GET', 'POST'])
@login_required
def manage_files():
    """
    Shows a page to view all generated files and allows deletion.
    """
    output_dir = current_app.config['OUTPUT_DIR']

    if request.method == 'POST':
        # This is a destructive action, log it clearly.
        user = session.get('user_id', 'Unknown')
        selected_files = request.form.getlist('selected_files')
        
        if not selected_files:
            flash('No files were selected for deletion.', 'warning')
            return redirect(url_for('files.manage_files'))

        logger.info(f"User '{user}' has initiated deletion of {len(selected_files)} file(s).")
        
        deleted_count, error_count = 0, 0
        for filename in selected_files:
            # Sanitize each filename for security.
            safe_filename = secure_filename(filename)
            file_path = os.path.join(output_dir, safe_filename)
            
            try:
                if os.path.isfile(file_path):
                    os.remove(file_path)
                    deleted_count += 1
                else:
                    logger.warning(f"File to delete was not found (perhaps already deleted): {file_path}")
                    error_count += 1
            except Exception as e:
                logger.error(f"Error deleting file {file_path}: {e}", exc_info=True)
                error_count += 1
        
        flash_message = f'{deleted_count} file(s) deleted successfully.'
        if error_count > 0:
            flash_message += f' {error_count} error(s) encountered.'
            flash(flash_message, 'warning')
        else:
            flash(flash_message, 'success')
            
        return redirect(url_for('files.manage_files'))

    # Logic for GET request: list all files.
    files_list = []
    try:
        # Search only for file types that our application generates.
        file_patterns = ['*.xlsx', '*.csv', '*.zip']
        for pattern in file_patterns:
            for file_path in glob.glob(os.path.join(output_dir, pattern)):
                try:
                    stat = os.stat(file_path)
                    files_list.append({
                        'name': os.path.basename(file_path),
                        'size_kb': round(stat.st_size / 1024, 2),
                        'modified': datetime.fromtimestamp(stat.st_mtime),
                    })
                except OSError:
                    # Can occur if the file is deleted while listing.
                    continue
    except Exception as e:
        logger.error(f"Error listing output directory '{output_dir}': {e}", exc_info=True)
        flash('An error occurred while trying to get the file list.', 'error')

    # Sort by modification date, newest first.
    files_list.sort(key=lambda x: x['modified'], reverse=True)
    
    return render_template('manage_files.html', files=files_list)